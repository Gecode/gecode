/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2002
 *     Guido Tack, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode {

  /**
   * \brief Dynamic low-propagation cost computation
   *
   * If \a n is less than 4, use constant low-costs, otherwise use \a pc.
   * \ingroup TaskActor
   */
  PropCost cost_lo(int n, PropCost pc);
  /**
   * \brief Dynamic high-propagation cost computation
   *
   * If \a n is less than 4, use constant hight-costs, otherwise use \a pc.
   * \ingroup TaskActor
   */
  PropCost cost_hi(int n, PropCost pc);


  /**
   * \defgroup TaskPropPat Propagator patterns
   *
   * The optional last Boolean argument (\a fd) to the constructor for creation
   * defines whether disposal must be forced. That is, if \a fd is true
   * the dispose member function of a propagator is called when the
   * space containing the propagator is deleted.
   * \ingroup TaskActor
   */

  //@{
  /**
   * \brief Unary propagator
   *
   * Stores single view of type \a View with propagation condition \a pc.
   */
  template <class View, PropCond pc>
  class UnaryPropagator : public Propagator {
  protected:
    /// Single view
    View x0;
    /// Constructor for cloning \a p
    UnaryPropagator(Space* home, bool share, UnaryPropagator& p);
    /// Constructor for rewriting \a p during cloning
    UnaryPropagator(Space* home, bool share, Propagator& p,
		    View x0);
    /// Constructor for creation
    UnaryPropagator(Space* home, View x0, bool fd=false);
  public:
    /// Cost function (defined as PC_UNARY_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Binary propagator
   *
   * Stores two views of type \a View with propagation condition \a pc.
   */
  template <class View, PropCond pc>
  class BinaryPropagator : public Propagator {
  protected:
    /// Two views
    View x0, x1;
    /// Constructor for cloning \a p
    BinaryPropagator(Space* home, bool share, BinaryPropagator& p);
    /// Constructor for creation
    BinaryPropagator(Space* home, View x0, View x1, bool fd=false);
    /// Constructor for rewriting \a p during cloning
    BinaryPropagator(Space* home, bool share, Propagator& p,
		     View x0, View x1);
  public:
    /// Cost function (defined as PC_BINARY_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Ternary propagator
   *
   * Stores three views of type \a View with propagation condition \a pc.
   */
  template <class View, PropCond pc>
  class TernaryPropagator : public Propagator {
  protected:
    /// Three views
    View x0, x1, x2;
    /// Constructor for cloning \a p
    TernaryPropagator(Space* home, bool share, TernaryPropagator& p);
    /// Constructor for creation
    TernaryPropagator(Space* home, View x0, View x1, View x2, bool fd=false);
    /// Constructor for rewriting \a p during cloning
    TernaryPropagator(Space* home, bool share, Propagator& p,
		      View x0, View x1, View x2);
  public:
    /// Cost function (defined as PC_TERNARY_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief n-ary propagator
   *
   * Stores array of views of type \a View with propagation condition \a pc.
   */
  template <class View, PropCond pc>
  class NaryPropagator : public Propagator {
  protected:
    /// Array of views
    ViewArray<View> x;
    /// Constructor for cloning \a p
    NaryPropagator(Space* home, bool share, NaryPropagator& p);
    /// Constructor for rewriting \a p during cloning
    NaryPropagator(Space* home, bool share, Propagator& p,
		   ViewArray<View>& x);
    /// Constructor for creation
    NaryPropagator(Space* home, ViewArray<View>& x, bool fd=false);
  public:
    /// Cost function (defined as dynamic PC_LINEAR_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief (n+1)-ary propagator
   *
   * Stores array of views and single view of type \a View with propagation 
   * condition \a pc.
   */
  template <class View, PropCond pc>
  class NaryOnePropagator : public Propagator {
  protected:
    /// Array of views
    ViewArray<View> x; 
    /// Single view
    View y;
    /// Constructor for cloning \a p
    NaryOnePropagator(Space* home, bool share, NaryOnePropagator& p);
    /// Constructor for rewriting \a p during cloning
    NaryOnePropagator(Space* home, bool share, Propagator& p,
		      ViewArray<View>& x, View y);
    /// Constructor for creation
    NaryOnePropagator(Space* home, ViewArray<View>& x, View y, bool fd=false);
  public:
    /// Cost function (defined as dynamic PC_LINEAR_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Inhomogeneous binary propagator
   *
   * Stores two views of type \a View0 and \a View1 with propagation
   * conditions \a pc0 and \a pc1.
   */
  template <class View0, PropCond pc0, class View1, PropCond pc1>
  class InhomBinaryPropagator : public Propagator {
  protected:
    View0 x0;
    View1 x1;
    /// Constructor for cloning
    InhomBinaryPropagator(Space* home,bool,InhomBinaryPropagator&);
    /// Constructor for creation
    InhomBinaryPropagator(Space* home,View0,View1,bool=false);
    /// Constructor for rewriting \a p during cloning
    InhomBinaryPropagator(Space* home, bool share, Propagator& p,
			  View0 x0, View1 x1);
  public:
    /// Cost function (defined as PC_BINARY_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Inhomogeneous ternary propagator
   *
   * Stores three views of type \a View0, \a View1, and \a View2
   * with propagation conditions \a pc0, \a pc1, and \a pc2.
   */
  template <class View0, PropCond pc0, class View1, PropCond pc1,
	    class View2, PropCond pc2>
  class InhomTernaryPropagator : public Propagator {
  protected:
    View0 x0;
    View1 x1;
    View2 x2;
    /// Constructor for cloning
    InhomTernaryPropagator(Space* home,bool,InhomTernaryPropagator&);
    /// Constructor for creation
    InhomTernaryPropagator(Space* home,View0,View1,View2,bool=false);
    /// Constructor for rewriting \a p during cloning
    InhomTernaryPropagator(Space* home, bool share, Propagator& p,
			   View0 x0, View1 x1, View2 x2);
  public:
    /// Cost function (defined as PC_TERNARY_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Inhomogeneous (n+1)-ary propagator
   *
   * Stores array of views of type \a View0 with propagation condition \a pc0
   * and a single view of type \a View1 with propagation condition \a pc1.
   */
  template <class View0, PropCond pc0, class View1, PropCond pc1>
  class InhomNaryOnePropagator : public Propagator {
  protected:
    /// Array of views
    ViewArray<View0> x; 
    /// Single view
    View1 y;
    /// Constructor for cloning \a p
    InhomNaryOnePropagator(Space* home, bool share, InhomNaryOnePropagator& p);
    /// Constructor for creation
    InhomNaryOnePropagator(Space* home, ViewArray<View0>& x, View1 y,
			   bool fd=false);
    /// Constructor for rewriting \a p during cloning
    InhomNaryOnePropagator(Space* home, bool share, Propagator& p,
			   ViewArray<View0>& x, View1 y);
  public:
    /// Cost function (defined as dynamic PC_LINEAR_LO)
    virtual PropCost cost(void) const;
    /// Delete propagator and return its size
    virtual size_t dispose(Space* home);
  };
  //@}






  /*
   * Dynamic cost computation
   *
   */

  forceinline PropCost
  cost_lo(int n, PropCost c) {
    if (n > 3) return c;
    if (n < 2) return PC_UNARY_LO;
    return (n > 2) ? PC_TERNARY_LO : PC_BINARY_LO;
  }

  forceinline PropCost
  cost_hi(int n, PropCost c) {
    if (n > 3) return c;
    if (n < 2) return PC_UNARY_HI;
    return (n > 2) ? PC_TERNARY_HI : PC_BINARY_HI;
  }

  /*
   * Unary propagators
   *
   */

  template <class View, PropCond pc>
  UnaryPropagator<View,pc>::UnaryPropagator
  (Space* home, View y0, bool fd)
    : Propagator(home,fd), x0(y0) {
    x0.subscribe(home,this,pc);
  }

  template <class View, PropCond pc>
  forceinline
  UnaryPropagator<View,pc>::UnaryPropagator
  (Space* home, bool share, UnaryPropagator<View,pc>& p)
    : Propagator(home,share,p) {
    x0.update(home,share,p.x0);
  }

  template <class View, PropCond pc>
  forceinline
  UnaryPropagator<View,pc>::UnaryPropagator
  (Space* home, bool share, Propagator& p, View y0)
    : Propagator(home,share,p) {
    x0.update(home,share,y0);
  }

  template <class View, PropCond pc>
  PropCost
  UnaryPropagator<View,pc>::cost(void) const {
    return PC_UNARY_LO;
  }

  template <class View, PropCond pc>
  size_t
  UnaryPropagator<View,pc>::dispose(Space* home) {
    if (!home->failed())
      x0.cancel(home,this,pc);
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * Binary propagators
   *
   */

  template <class View, PropCond pc>
  BinaryPropagator<View,pc>::BinaryPropagator
  (Space* home, View y0, View y1, bool fd)
    : Propagator(home,fd), x0(y0), x1(y1) {
    x0.subscribe(home,this,pc);
    x1.subscribe(home,this,pc);
  }

  template <class View, PropCond pc>
  forceinline
  BinaryPropagator<View,pc>::BinaryPropagator
  (Space* home, bool share, BinaryPropagator<View,pc>& p)
    : Propagator(home,share,p) {
    x0.update(home,share,p.x0);
    x1.update(home,share,p.x1);
  }

  template <class View, PropCond pc>
  forceinline
  BinaryPropagator<View,pc>::BinaryPropagator
  (Space* home, bool share, Propagator& p, View y0, View y1)
    : Propagator(home,share,p) {
    x0.update(home,share,y0);
    x1.update(home,share,y1);
  }

  template <class View, PropCond pc>
  PropCost
  BinaryPropagator<View,pc>::cost(void) const {
    return PC_BINARY_LO;
  }

  template <class View, PropCond pc>
  size_t
  BinaryPropagator<View,pc>::dispose(Space* home) {
    if (!home->failed()) {
      x0.cancel(home,this,pc);
      x1.cancel(home,this,pc);
    }
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * Ternary propagators
   *
   */

  template <class View, PropCond pc>
  TernaryPropagator<View,pc>::TernaryPropagator
  (Space* home, View y0, View y1, View y2, bool fd)
    : Propagator(home,fd), x0(y0), x1(y1), x2(y2) {
    x0.subscribe(home,this,pc);
    x1.subscribe(home,this,pc);
    x2.subscribe(home,this,pc);
  }

  template <class View, PropCond pc>
  forceinline
  TernaryPropagator<View,pc>::TernaryPropagator
  (Space* home, bool share, TernaryPropagator<View,pc>& p)
    : Propagator(home,share,p) {
    x0.update(home,share,p.x0);
    x1.update(home,share,p.x1);
    x2.update(home,share,p.x2);
  }

  template <class View, PropCond pc>
  forceinline
  TernaryPropagator<View,pc>::TernaryPropagator
  (Space* home, bool share, Propagator& p, View y0, View y1, View y2)
    : Propagator(home,share,p) {
    x0.update(home,share,y0);
    x1.update(home,share,y1);
    x2.update(home,share,y2);
  }

  template <class View, PropCond pc>
  PropCost
  TernaryPropagator<View,pc>::cost(void) const {
    return PC_TERNARY_LO;
  }

  template <class View, PropCond pc>
  size_t
  TernaryPropagator<View,pc>::dispose(Space* home) {
    if (!home->failed()) {
      x0.cancel(home,this,pc);
      x1.cancel(home,this,pc);
      x2.cancel(home,this,pc);
    }
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * Nary propagators
   *
   */

  template <class View, PropCond pc>
  NaryPropagator<View,pc>::NaryPropagator
  (Space* home, ViewArray<View>& y, bool fd)
    : Propagator(home,fd), x(y) {
    x.subscribe(home,this,pc);
  }

  template <class View, PropCond pc>
  forceinline
  NaryPropagator<View,pc>::NaryPropagator
  (Space* home, bool share, NaryPropagator<View,pc>& p)
    : Propagator(home,share,p) {
    x.update(home,share,p.x);
  }

  template <class View, PropCond pc>
  forceinline
  NaryPropagator<View,pc>::NaryPropagator
  (Space* home, bool share, Propagator& p, ViewArray<View>& x0)
    : Propagator(home,share,p) {
    x.update(home,share,x0);
  }

  template <class View, PropCond pc>
  PropCost
  NaryPropagator<View,pc>::cost(void) const {
    return cost_lo(x.size(), PC_LINEAR_LO);
  }

  template <class View, PropCond pc>
  size_t
  NaryPropagator<View,pc>::dispose(Space* home) {
    if (!home->failed())
      x.cancel(home,this,pc);
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * NaryOne (one additional variable) propagators
   *
   */

  template <class View, PropCond pc>
  NaryOnePropagator<View,pc>::NaryOnePropagator
  (Space* home, ViewArray<View>& x0, View y0, bool fd)
    : Propagator(home,fd), x(x0), y(y0) {
    x.subscribe(home,this,pc);
    y.subscribe(home,this,pc);
  }

  template <class View, PropCond pc>
  forceinline
  NaryOnePropagator<View,pc>::NaryOnePropagator
  (Space* home, bool share, NaryOnePropagator<View,pc>& p)
    : Propagator(home,share,p) {
    x.update(home,share,p.x);
    y.update(home,share,p.y);
  }

  template <class View, PropCond pc>
  forceinline
  NaryOnePropagator<View,pc>::NaryOnePropagator
  (Space* home, bool share, Propagator& p, ViewArray<View>& x0, View y0)
    : Propagator(home,share,p) {
    x.update(home,share,x0);
    y.update(home,share,y0);
  }

  template <class View, PropCond pc>
  PropCost
  NaryOnePropagator<View,pc>::cost(void) const {
    return cost_lo(x.size()+1, PC_LINEAR_LO);
  }

  template <class View, PropCond pc>
  size_t
  NaryOnePropagator<View,pc>::dispose(Space* home) {
    if (!home->failed()) {
      x.cancel(home,this,pc);
      y.cancel(home,this,pc);
    }
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * Inhomogeneous binary propagators
   *
   */

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  InhomBinaryPropagator<View0,pc0,View1,pc1>::InhomBinaryPropagator
  (Space* home, View0 y0, View1 y1, bool fd)
    : Propagator(home,fd), x0(y0), x1(y1) {
    x0.subscribe(home,this,pc0);
    x1.subscribe(home,this,pc1);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  forceinline
  InhomBinaryPropagator<View0,pc0,View1,pc1>::InhomBinaryPropagator
  (Space* home, bool share, InhomBinaryPropagator<View0,pc0,View1,pc1>& p)
    : Propagator(home,share,p) {
    x0.update(home,share,p.x0);
    x1.update(home,share,p.x1);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  forceinline
  InhomBinaryPropagator<View0,pc0,View1,pc1>::InhomBinaryPropagator
  (Space* home, bool share, Propagator& p, View0 y0, View1 y1)
    : Propagator(home,share,p) {
    x0.update(home,share,y0);
    x1.update(home,share,y1);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  PropCost
  InhomBinaryPropagator<View0,pc0,View1,pc1>::cost(void) const {
    return PC_BINARY_LO;
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  size_t
  InhomBinaryPropagator<View0,pc0,View1,pc1>::dispose(Space* home) {
    if (!home->failed()) {
      x0.cancel(home,this,pc0);
      x1.cancel(home,this,pc1);
    }
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * Inhomogeneous ternary propagators
   *
   */

  template <class View0, PropCond pc0, class View1, PropCond pc1,
	    class View2, PropCond pc2>
  InhomTernaryPropagator<View0,pc0,View1,pc1,View2,pc2>::
  InhomTernaryPropagator(Space* home, View0 y0, View1 y1, View2 y2, bool fd)
    : Propagator(home,fd), x0(y0), x1(y1), x2(y2) {
    x0.subscribe(home,this,pc0);
    x1.subscribe(home,this,pc1);
    x2.subscribe(home,this,pc2);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1,
	    class View2, PropCond pc2>
  forceinline
  InhomTernaryPropagator<View0,pc0,View1,pc1,View2,pc2>::
  InhomTernaryPropagator(Space* home, bool share,
			 InhomTernaryPropagator<View0,pc0,View1,pc1,
			 View2,pc2>& p)
    : Propagator(home,share,p) {
    x0.update(home,share,p.x0);
    x1.update(home,share,p.x1);
    x2.update(home,share,p.x2);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1,
	    class View2, PropCond pc2>
  forceinline
  InhomTernaryPropagator<View0,pc0,View1,pc1,View2,pc2>::InhomTernaryPropagator
  (Space* home, bool share, Propagator& p, View0 y0, View1 y1, View2 y2)
    : Propagator(home,share,p) {
    x0.update(home,share,y0);
    x1.update(home,share,y1);
    x2.update(home,share,y2);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1,
	    class View2, PropCond pc2>
  PropCost
  InhomTernaryPropagator<View0,pc0,View1,pc1,View2,pc2>::cost(void) const {
    return PC_BINARY_LO;
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1,
	    class View2, PropCond pc2>
  size_t
  InhomTernaryPropagator<View0,pc0,View1,pc1,View2,pc2>::
  dispose(Space* home) {
    if (!home->failed()) {
      x0.cancel(home,this,pc0);
      x1.cancel(home,this,pc1);
      x2.cancel(home,this,pc2);
    }
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }


  /*
   * InhomNaryOne (one additional variable) propagators
   *
   */

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  InhomNaryOnePropagator<View0,pc0,View1,pc1>::InhomNaryOnePropagator
  (Space* home, ViewArray<View0>& x0, View1 y0, bool fd)
    : Propagator(home,fd), x(x0), y(y0) {
    x.subscribe(home,this,pc0);
    y.subscribe(home,this,pc1);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  forceinline
  InhomNaryOnePropagator<View0,pc0,View1,pc1>::InhomNaryOnePropagator
  (Space* home, bool share, InhomNaryOnePropagator<View0,pc0,View1,pc1>& p)
    : Propagator(home,share,p) {
    x.update(home,share,p.x);
    y.update(home,share,p.y);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  forceinline
  InhomNaryOnePropagator<View0,pc0,View1,pc1>::InhomNaryOnePropagator
  (Space* home, bool share, Propagator& p, ViewArray<View0>& x0, View1 y0)
    : Propagator(home,share,p) {
    x.update(home,share,x0);
    y.update(home,share,y0);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  PropCost
  InhomNaryOnePropagator<View0,pc0,View1,pc1>::cost(void) const {
    return cost_lo(x.size()+1, PC_LINEAR_LO);
  }

  template <class View0, PropCond pc0, class View1, PropCond pc1>
  size_t
  InhomNaryOnePropagator<View0,pc0,View1,pc1>::dispose(Space* home) {
    if (!home->failed()) {
      x.cancel(home,this,pc0);
      y.cancel(home,this,pc1);
    }
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }

}

// STATISTICS: kernel-other
