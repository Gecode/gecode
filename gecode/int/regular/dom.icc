/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/iter.hh"

#include "gecode/support/static-stack.hh"
#include "gecode/support/block-allocator.hh"

namespace Gecode { namespace Int { namespace Regular {


  /*
   * Classes for the layered graph
   *
   */

  /**
   * \brief States are described by number of incoming and outgoing edges
   */
  class State {
  public:
    unsigned int i_deg;
    unsigned int o_deg;
  };

  class Edge;
  typedef Support::BlockAllocator<Edge> EdgeAllocator;

  /**
   * \brief %Edge in the layered graph
   */
  class Edge : public Support::BlockClient<Edge> {
  public:
    int    val;
    State* i_state;
    State* o_state;
    Edge*  next;
  };

  /**
   * \name Flags for modification in layer
   */
  //@{
  const int MOD_NONE  = 0; ///< No modification
  const int MOD_IDEG  = 1; ///< Indegree has become zero
  const int MOD_ODEG  = 2; ///< Outdegree has become zero
  //@}

  /**
   * \brief A layer in the layered graph
   */
  class Layer {
  public:
    Edge*        edges;
    unsigned int size;
    int          modified;
  };

  /// %LayeredGraph as data structure used for propagation in regular
  template <class View>
  class Dom<View>::LayeredGraph {
  private:
    EdgeAllocator ea;
    size_t        state_size;
    State*        state_mem;
    Layer         _layer;    // One addional layer (makes layers[-1] okay)
    Layer         layers[2]; // Dynamically adjusted (also allow layers[...+1])
  public:
    /// Construct layered graph
    LayeredGraph(ViewArray<View> x, const DFA& d);
    /// Release layered graph
    ~LayeredGraph(void);

    /// Prune initially for view sequence \a x
    ExecStatus prune_initial(Space* home, Propagator* p, ViewArray<View> x);
    /// Prune incrementally for view sequence \a x
    ExecStatus prune(Space* home, Propagator* p, ViewArray<View> x);

    /// Return memory required for layered graph
    size_t size(void) const;
    static void* operator new(size_t,int);
    static void  operator delete(void*);
    static void  operator delete(void*,int);
  };



  /**
   * \brief Iterator for telling variable domains by scanning transitions
   *
   */
  class EdgeRanges {
  private:
    const Edge* e1; const Edge* e2;
  public:
    EdgeRanges(void);
    EdgeRanges(const Edge*);
    void init(const Edge*);
    bool operator()(void) const;
    void operator++(void);
    int min(void) const;
    int max(void) const;
    unsigned int width(void) const;
  };

  forceinline
  EdgeRanges::EdgeRanges(void) {}
  forceinline
  EdgeRanges::EdgeRanges(const Edge* e)
    : e1(e), e2(e) {
    assert(e1);
    // e2 always points to the end of  the interval
    while ((e2->next != NULL) && (e2->next->val <= e2->val+1))
      e2 = e2->next;
  }
  forceinline void
  EdgeRanges::init(const Edge* e) {
    e1=e; e2=e;
    assert(e1);
    // e2 always points to the end of  the interval
    while ((e2->next != NULL) && (e2->next->val <= e2->val+1))
      e2 = e2->next;
  }

  forceinline bool
  EdgeRanges::operator()(void) const {
    return e1 != NULL;
  }

  forceinline void
  EdgeRanges::operator++(void) {
    e1 = e2->next;
    if (e1 != NULL) {
      e2 = e1;
      while ((e2->next != NULL) && (e2->next->val <= e2->val+1))
        e2 = e2->next;
    }
  }

  forceinline int
  EdgeRanges::min(void) const {
    return e1->val;
  }
  forceinline int
  EdgeRanges::max(void) const {
    return e2->val;
  }
  forceinline unsigned int
  EdgeRanges::width(void) const {
    return max()-min()+1;
  }



  /*
   * The layered graph
   *
   */

  template <class View>
  forceinline
  Dom<View>::LayeredGraph::LayeredGraph(ViewArray<View> x, const DFA& dfa) {
    int n = x.size();
    unsigned int n_states = dfa.n_states();

    // Allocate memory
    state_size = sizeof(State)*(n+1)*n_states;
    state_mem  = reinterpret_cast<State*>(Memory::malloc(state_size));


    // Initialize states (indegree and outdegree)
    for (int i = (n+1)*n_states; i--; ) {
      state_mem[i].i_deg = 0;
      state_mem[i].o_deg = 0;
    }

    // Mark initial state as being reachable
    state_mem[0].i_deg = 1;

    // Mark final states as reachable as well
    for (int s = dfa.final_fst(); s < dfa.final_lst(); s++)
      state_mem[n*n_states + s].o_deg = 1;

    // First pass: add transitions
    for (int i = 0; i < n; i++) {
      Edge** p = &layers[i].edges;
      // Enter links leaving reachable states (indegree != 0)
      DFA::Transitions  t_a(dfa);
      ViewRanges<View>    rx(x[i]);
      while (rx() && t_a()) {
        const DFA::Transition* t = t_a.transition();
        // Compute pointers to states
        State* i_state = state_mem + (i  )*n_states + t->i_state;
        State* o_state = state_mem + (i+1)*n_states + t->o_state;
        if (t->symbol > rx.max()) {
          ++rx;
        } else if ((t->symbol >= rx.min()) && (i_state->i_deg > 0)) {
          // Add new transition as state is reachable
          i_state->o_deg++; o_state->i_deg++;
          Edge* e = new (ea) Edge;
          e->i_state = i_state;
          e->val     = t->symbol;
          e->o_state = o_state;
          *p = e;
          p = &e->next;
          ++t_a;
        } else {
          ++t_a;
        }
      }
      // Write endmarker for edges
      *p = NULL;
    }
  }

  template <class View>
  forceinline ExecStatus
  Dom<View>::LayeredGraph::prune_initial(Space* home, Propagator* p,
                                         ViewArray<View> x) {
    // Second pass: prune all transitions that do not lead to final state
    for (int i = x.size(); i--; ) {
      Edge** p = &layers[i].edges;
      Edge*  e = *p;
      while (e != NULL) {
        if (e->o_state->o_deg != 0) {
          // This state is still reachable, keep edge
          p = &e->next;
        } else {
          // Unreachable state, prune edge
          *p = e->next;
          e->i_state->o_deg--; e->o_state->i_deg--;
        }
        e = e->next;
      }
      *p = NULL;
    }

    // Tell back variable domains
    ExecStatus es = ES_FIX;
    for (int i=x.size(); i--; ) {
      if (layers[i].edges == NULL)
        return ES_FAILED;
      if (x[i].modified())
        es = ES_NOFIX;
      EdgeRanges er(layers[i].edges);
      if (x[i].modified()) {
        GECODE_ME_CHECK(x[i].inter(home,er));
      } else {
        x[i].narrow(home,er);
      }
      // Initialize size and modification data
      layers[i].modified = MOD_NONE;
      layers[i].size     = x[i].size();
    }
    for (int i=x.size(); i--; )
      if (!x[i].assigned())
        return es;
    return ES_SUBSUMED(p,home);
  }

  template <class View>
  forceinline ExecStatus
  Dom<View>::LayeredGraph::prune(Space* home, Propagator* p, 
                                 ViewArray<View> x) {
    int n = x.size();
    // Prune edges for which no value support exists
    for (int i = 0; i < n; i++)
      if (layers[i].size != x[i].size()) {
        layers[i].size = x[i].size();
        Edge** p = &layers[i].edges;
        Edge*  e = *p;
        ViewRanges<View> rx(x[i]);
        while (rx() && (e != NULL)) {
          if (e->val > rx.max()) {
            ++rx;
          } else if ((e->val < rx.min()) || (e->i_state->i_deg == 0)) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0)
              layers[i-1].modified |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0)
              layers[i+1].modified |= MOD_IDEG;
            // Remove this edge
            *p = e->next; e = e->next;
          } else {
            // Keep edge
            p = &e->next; e = e->next;
          }
        }
        *p = NULL;
        // Remove all remaining edges
        while (e != NULL) {
          // Adapt states
          if (--e->i_state->o_deg == 0)
            layers[i-1].modified |= MOD_ODEG;
          if (--e->o_state->i_deg == 0)
            layers[i+1].modified |= MOD_IDEG;
          e = e->next;
        }
        // Write endmarker for edges
      }  else if (layers[i].modified & MOD_IDEG) {
        assert(layers[i].size == x[i].size());
        Edge** p = &layers[i].edges;
        Edge*  e = *p;
        while (e != NULL) {
          if (e->i_state->i_deg == 0) {
            // Adapt states
            if (--e->i_state->o_deg == 0)
              layers[i-1].modified |= MOD_ODEG;
            if (--e->o_state->i_deg == 0)
              layers[i+1].modified |= MOD_IDEG;
            // Remove this edge
            *p = e->next;
          } else {
            // Keep edge
            p = &e->next;
          }
          e = e->next;
        }
        // Write endmarker for edges
        *p = NULL;
      }

    for (int i=n; i--; )
      if (layers[i].modified & MOD_ODEG) {
        Edge** p = &layers[i].edges;
        Edge*  e = *p;
        while (e != NULL) {
          if (e->o_state->o_deg != 0) {
            // This state is still reachable, keep edge
            p = &e->next;
          } else {
            // Unreachable state, prune edge
            if (--e->i_state->o_deg == 0)
              layers[i-1].modified |= MOD_ODEG;
            --e->o_state->i_deg;
            *p = e->next;
          }
          e = e->next;
        }
        *p = NULL;
      }
    // Tell back variable domains
    ExecStatus es = ES_FIX;
    for (int i=n; i--; )
      if (layers[i].modified) {
        layers[i].modified = MOD_NONE;
        if (layers[i].edges == NULL)
          return ES_FAILED;
        if (x[i].modified())
          es = ES_NOFIX;
        EdgeRanges er(layers[i].edges);
        if (x[i].modified()) {
          GECODE_ME_CHECK(x[i].inter(home,er));
        } else {
          x[i].narrow(home,er);
        }
        layers[i].size = x[i].size();
      }
    for (int i=x.size(); i--; )
      if (!x[i].assigned())
        return es;
    return ES_SUBSUMED(p,home);
  }

  template <class View>
  forceinline
  Dom<View>::LayeredGraph::~LayeredGraph(void) {
    Memory::free(state_mem);
  }

  template <class View>
  forceinline size_t
  Dom<View>::LayeredGraph::size(void) const {
    return state_size + ea.size();
  }

  template <class View>
  forceinline void
  Dom<View>::LayeredGraph::operator delete(void* p) {
    Memory::free(p);
  }

  template <class View>
  forceinline void
  Dom<View>::LayeredGraph::operator delete(void* p, int) {
    Memory::free(p);
  }

  template <class View>
  forceinline void*
  Dom<View>::LayeredGraph::operator new(size_t s, int n) {
    // n ist the number of variables
    return Memory::malloc(sizeof(LayeredGraph) + n*sizeof(Layer));
  }

  template <class View>
  size_t
  Dom<View>::dispose(Space* home) {
    Propagator::unforce(home);
    dfa.~DFA();
    delete lg;
    (void) NaryPropagator<View,PC_INT_DOM>::dispose(home);
    return sizeof(*this);
  }

  template <class View>
  ExecStatus
  Dom<View>::propagate(Space* home) {
    if (lg == NULL) {
      lg = new (this->x.size()) LayeredGraph(this->x,dfa);
      return lg->prune_initial(home,this,this->x);
    } else {
      return lg->prune(home,this,this->x);
    }
  }

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, ViewArray<View>& x, DFA& d)
    : NaryPropagator<View,PC_INT_DOM>(home,x),
      dfa(d), lg(NULL) {
    Propagator::force(home);
  }

  template <class View>
  ExecStatus
  Dom<View>::post(Space* home, ViewArray<View>& x, DFA& d) {
    (void) new (home) Dom<View>(home,x,d);
    return ES_OK;
  }

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, bool share, Dom<View>& p)
    : NaryPropagator<View,PC_INT_DOM>(home,share,p), lg(NULL) {
    dfa.update(share,p.dfa);
  }

  template <class View>
  void
  Dom<View>::flush(void) {
    delete lg; lg = NULL;
  }

  template <class View>
  size_t
  Dom<View>::size(void) const {
    return (lg != NULL) ? lg->size() : 0;
  }

  template <class View>
  PropCost
  Dom<View>::cost(void) const {
    return cost_hi(this->x.size(), PC_LINEAR_HI);
  }

  template <class View>
  Actor*
  Dom<View>::copy(Space* home, bool share) {
    return new (home) Dom<View>(home,share,*this);
  }

}}}

// STATISTICS: int-prop

