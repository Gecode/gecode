/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */        

namespace Gecode { namespace Int { namespace Sorted {

  /**
   *  \brief Build \f$\sigma\f$
   *
   *  Creates a sorting permutation \f$\sigma\f$ by sorting the
   *  views in \a x according to their lower bounds
   */

  template <class View, class Tuple, bool Perm>
  inline void
  sort_sigma(ViewArray<Tuple>& xz, bool fixed) {
    int xs = xz.size();

    // test for equal bounds
    if (Perm) {
      TupleMinIncExt<Tuple> min_inc;
      Support::quicksort<Tuple, TupleMinIncExt<Tuple> >(&xz[0], xs, min_inc);
    } else {
      TupleMinInc<Tuple> min_inc;
      Support::quicksort<Tuple, TupleMinInc<Tuple> >(&xz[0], xs, min_inc);
    }
  }

  /**
   *  \brief Build \f$\tau\f$
   *
   *  Creates a sorting permutation \f$\tau\f$ by sorting
   *  a given array of indices in \a tau according to the upper bounds
   *  of the views in \a x
   */

  template <class View, class Tuple, bool Perm>
  inline void
  sort_tau(ViewArray<Tuple>& xz, int tau[]) {
    int xs = xz.size();

    if (Perm) {
      TupleMaxIncExt<Tuple> ltmax(xz);
      Support::quicksort(&(*tau), xs, ltmax);
    } else {
      TupleMaxInc<Tuple> ltmax(xz);
      Support::quicksort(&(*tau), xs, ltmax);
    }
  }

  /**
   * \brief Performing normalization on the views in \a y
   *
   * The views in \a y are called normalized if
   * \f$\forall i\in\{0,\dots, n-1\}: min(y_0) \leq \dots \leq min(y_{n-1}) \wedge
   *  max(y_0) \leq \dots \leq max(y_{n-1})\f$ holds.
   */
  template <class View, class Tuple>
  inline bool
  normalize(Space* home,
            ViewArray<View>& y,
            ViewArray<Tuple>& xz,
            bool& nofix) {

    int ys = y.size();
    for (int i = 1; i < ys; i++) {
      ModEvent me_lb = y[i].gq(home, y[i - 1].min());
      if (me_failed(me_lb))
        return false;
      nofix |= (me_modified(me_lb) && y[i - 1].min() != y[i].min());
    }

    for (int i = ys - 1; i--; ) {
      ModEvent me_ub = y[i].lq(home, y[i + 1].max());
      if (me_failed(me_ub))
        return false;
      nofix |= (me_modified(me_ub) && y[i + 1].max() != y[i].max());
    }

    int xs = xz.size();
    for (int i = xs; i--; ) {
      ModEvent me = xz[i][0].gq(home, y[0].min());
      if (me_failed(me))
        return false;
      nofix |= (me_modified(me) && xz[i][0].min() != y[0].min());

      me = xz[i][0].lq(home, y[xs - 1].max());
      if (me_failed(me))
        return false;
      nofix |= (me_modified(me) && xz[i][0].max() != y[xs - 1].max());
    }
    return true;
  }

  /**
   *  \brief Bounds consistency on the permutation views
   *
   *  Check, whether the permutation view are bounds consistent.
   *  This function tests, whether there are "crossing edges", i.e.
   *  whether the current domains permit matchings between unsorted views
   *  \a x and the sorted variables \a y violating the property
   *  that \a y is sorted.
   */

  template<class View, class Tuple, bool Perm>
  inline bool
  perm_bc(Space* home, int tau[],
          SccComponent sinfo[],        
          int scclist[],
          ViewArray<Tuple>& xz,
          bool& crossingedge,
          bool& nofix) {

    int ps = xz.size();

    for (int i = 1; i < ps; i++) {
      // if there are "crossed edges"
      if (xz[i - 1][0].min() < xz[i][0].min()) {
        if (xz[i - 1][1].min() > xz[i][1].min()) {
          if (xz[i][1].min() != sinfo[scclist[i]].leftmost) {
            // edge does not take part in solution
            if (xz[i][1].assigned()) { // vital edge do not remove it
              if (xz[i - 1][0].max() < xz[i][0].min()) {
                // invalid permutation
                // the upper bound sorting cannot fix this
                return false;
              }
            } else {
              crossingedge = true;
              // and the permutation can still be changed
              // fix the permutation, i.e. modify z
              ModEvent me_z = xz[i][1].gq(home, xz[i - 1][1].min());
              if (me_failed(me_z)) {
                return false;
              }
              nofix |= ( me_modified(me_z) &&
                         xz[i - 1][1].min() != xz[i][1].min());
            }
          }
        }
      }
    }

    // the same check as above for the upper bounds
    for (int i = ps - 1; i--; ) {
      if (xz[tau[i]][0].max() < xz[tau[i + 1]][0].max()) {
        if (xz[tau[i]][1].max() > xz[tau[i + 1]][1].max()) {
          if (xz[tau[i]][1].max() != sinfo[scclist[tau[i]]].rightmost) {
            // edge does not take part in solution
            if (xz[tau[i]][1].assigned()) {
              if (xz[tau[i + 1]][0].min() > xz[tau[i]][0].max()) {
                // invalid permutation
                return false;
              }
            } else {
              crossingedge = true;
              ModEvent me_z = xz[tau[i]][1].lq(home, xz[tau[i + 1]][1].max());
              if (me_failed(me_z)) {
                return false;
              }
              nofix |= (me_modified(me_z) &&
                        xz[tau[i + 1]][1].max() != xz[tau[i]][1].max());
            }
          }
        }
      }
    }

    return true;
  }

}}}

// STATISTICS: int-prop

