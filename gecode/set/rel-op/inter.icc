/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Contributing authors:
 *     Gabor Szokoli <szokoli@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2004
 *     Christian Schulte, 2004
 *     Gabor Szokoli, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { namespace Set { namespace RelOp {

  /*
   * "Ternary intersection" propagator
   *
   */

  template <class View0, class View1, class View2> ExecStatus
  Intersection<View0,View1,View2>::post(Space* home,
                                        View0 x0,View1 x1,View2 x2) {
    (void) new (home) Intersection<View0,View1,View2>(home,x0,x1,x2);
    return ES_OK;
  }

  template <class View0, class View1, class View2>
  Actor*
  Intersection<View0,View1,View2>::copy(Space* home, bool share) {
    return new (home) Intersection(home,share,*this);
  }

  template <class View0, class View1, class View2>
  Support::Symbol
  Intersection<View0,View1,View2>::name(void) {
    return Reflection::mangle<View0,View1,View2>("Set::RelOp::Intersection");
  }

  template <class View0, class View1, class View2>
  Reflection::ActorSpec&
  Intersection<View0,View1,View2>::spec(Space* home, Reflection::VarMap& m) {
    return MixTernaryPropagator<View0,PC_SET_ANY,View1,PC_SET_ANY,
      View2,PC_SET_ANY>::spec(home, m, name());
  }

  template <class View0, class View1, class View2>
  ExecStatus
  Intersection<View0,View1,View2>::propagate(Space* home) {

    bool x0ass=x0.assigned();
    bool x1ass=x1.assigned();
    bool x2ass=x2.assigned();

    {
      GlbRanges<View2> x2lb(x2);
      GECODE_ME_CHECK( x0.includeI(home,x2lb) );
    }
    {
      GlbRanges<View2> x2lb(x2);
      GECODE_ME_CHECK( x1.includeI(home,x2lb) );
    }
    {
      GlbRanges<View0> x0lb(x0);
      LubRanges<View2> x2ub(x2);
      Iter::Ranges::Diff<GlbRanges<View0>,LubRanges<View2> > m1(x0lb,x2ub);
      GECODE_ME_CHECK( x1.excludeI(home,m1) );
    }
    {
      GlbRanges<View1> x1lb(x1);
      LubRanges<View2> x2ub(x2);

      Iter::Ranges::Diff<GlbRanges<View1>,LubRanges<View2> > m2(x1lb,x2ub);
      GECODE_ME_CHECK( x0.excludeI(home,m2) );
    }
    {
      GlbRanges<View0> x0lb(x0);
      GlbRanges<View1> x1lb(x1);
      Iter::Ranges::Inter<GlbRanges<View0>,GlbRanges<View1> > i1(x0lb,x1lb);
      GECODE_ME_CHECK( x2.includeI(home,i1) );
    }
    {
      LubRanges<View0> x0ub(x0);
      LubRanges<View1> x1ub(x1);
      Iter::Ranges::Inter<LubRanges<View0>,LubRanges<View1> > i2(x0ub,x1ub);
      GECODE_ME_CHECK( x2.intersectI(home,i2) );
    }
    unsigned int m, n;
    {
      LubRanges<View0> x0ub(x0);
      LubRanges<View1> x1ub(x1);
      Iter::Ranges::Union<LubRanges<View0>,LubRanges<View1> > u1(x0ub,x1ub);
      m = Iter::Ranges::size(u1);
      n = x0.cardMin()+x1.cardMin();
      if (n>m)
        GECODE_ME_CHECK( x2.cardMin(home,n-m) );
    }
    unsigned int s2;
    {
      LubRanges<View0> x0ub(x0);
      GlbRanges<View1> x1lb(x1);
      Iter::Ranges::Diff<GlbRanges<View1>,LubRanges<View0> > d2(x1lb,x0ub);
      s2 = Iter::Ranges::size(d2);
      assert (s2 <= x1.cardMax());
      GECODE_ME_CHECK( x2.cardMax(home,x1.cardMax()-s2) );
    }
    {
      LubRanges<View1> x1ub(x1);
      GlbRanges<View0> x0lb(x0);
      Iter::Ranges::Diff<GlbRanges<View0>,LubRanges<View1> > d1 (x0lb,x1ub);
      unsigned int s1 = Iter::Ranges::size(d1);
      assert (s1 <= x0.cardMax());
      GECODE_ME_CHECK( x2.cardMax(home,x0.cardMax()-s1) );
      if (m+x2.cardMax() > x1.cardMin())
        GECODE_ME_CHECK( x0.cardMax(home,m+x2.cardMax()-x1.cardMin()) );
      //I might have to recaluclate m here?
      if (m+x2.cardMax() > x0.cardMin())
        GECODE_ME_CHECK( x1.cardMax(home,m+x2.cardMax()-x0.cardMin()) );
      //s1 and s2 could be outdated too...
      GECODE_ME_CHECK( x0.cardMin(home,s1+x2.cardMin()) );
      GECODE_ME_CHECK( x1.cardMin(home,s2+x2.cardMin()) );
    }
    if ( x0ass + x1ass + x2ass >= 2 ) return ES_SUBSUMED(this,home);

    return ES_NOFIX;
  }

  template <class View0, class View1, class View2>
  forceinline
  Intersection<View0,View1,View2>::Intersection(Space* home,
                                             View0 y0,View1 y1,View2 y2)
    : MixTernaryPropagator<View0,PC_SET_ANY,View1,PC_SET_ANY,
                             View2,PC_SET_ANY>(home,y0,y1,y2) {}

  template <class View0, class View1, class View2>
  forceinline
  Intersection<View0,View1,View2>::Intersection(Space* home, bool share,
                                             Intersection<View0,View1,View2>& p)
    : MixTernaryPropagator<View0,PC_SET_ANY,View1,PC_SET_ANY,
                             View2,PC_SET_ANY>(home,share,p) {}

  /*
   * "Nary intersection" propagator
   *
   */

  template <class View0, class View1>
  forceinline
  IntersectionN<View0,View1>::IntersectionN(Space* home, ViewArray<View0>& x,
                                            View1 y)
    : MixNaryOnePropagator<View0,PC_SET_ANY,View1,PC_SET_ANY>(home,x,y),
      intOfDets(home) {
    shared = x.shared() || viewarrayshared(x,y);
  }

  template <class View0, class View1>
  forceinline
  IntersectionN<View0,View1>::IntersectionN(Space* home, ViewArray<View0>& x,
                                            const IntSet& z, View1 y)
    : MixNaryOnePropagator<View0,PC_SET_ANY,View1,PC_SET_ANY>(home,x,y),
      intOfDets(home) {
    shared = x.shared() || viewarrayshared(x,y);
    IntSetRanges rz(z);
    intOfDets.intersectI(home, rz);
  }

  template <class View0, class View1>
  forceinline
  IntersectionN<View0,View1>::IntersectionN(Space* home, bool share,
                                            IntersectionN& p)
    : MixNaryOnePropagator<View0,PC_SET_ANY,View1,PC_SET_ANY>(home,share,p),
      shared(p.shared),
      intOfDets() {
    intOfDets.update(home, p.intOfDets);
  }

  template <class View0, class View1>
  ExecStatus
  IntersectionN<View0,View1>::post(Space* home,
                                   ViewArray<View0>& x, View1 y) {
    switch (x.size()) {
    case 0:
      GECODE_ME_CHECK(y.cardMin(home, Limits::Set::card_max));
      return ES_OK;
    case 1:
      return Rel::Eq<View0,View1>::post(home, x[0], y);
    case 2:
      return Intersection<View0,View0,View1>::post(home, x[0], x[1], y);
    default:
      (void) new (home) IntersectionN<View0,View1>(home,x,y);
      return ES_OK;
    }
  }

  template <class View0, class View1>
  ExecStatus
  IntersectionN<View0,View1>::post(Space* home, ViewArray<View0>& x,
                                   const IntSet& z, View1 y) {
    (void) new (home) IntersectionN<View0,View1>(home,x,z,y);
    return ES_OK;
  }

  template <class View0, class View1>
  Actor*
  IntersectionN<View0,View1>::copy(Space* home, bool share) {
    return new (home) IntersectionN<View0,View1>(home,share,*this);
  }

  template <class View0, class View1>
  PropCost
  IntersectionN<View0,View1>::cost(void) const {
    return PC_QUADRATIC_LO;
  }

  template <class View0, class View1>
  Support::Symbol
  IntersectionN<View0,View1>::name(void) {
    return Reflection::mangle<View0,View1>("Set::RelOp::IntersectionN");
  }

  template <class View0, class View1>
  Reflection::ActorSpec&
  IntersectionN<View0,View1>::spec(Space* home, Reflection::VarMap& m) {
    Reflection::ActorSpec& s =
      MixNaryOnePropagator<View0,PC_SET_ANY,View1,PC_SET_ANY>
        ::spec(home, m, name());
    int count = 0;
    for (BndSetRanges iod(intOfDets); iod(); ++iod)
      count++;
    Reflection::IntArrayArg* a = new Reflection::IntArrayArg(count*2);
    count = 0;
    for (BndSetRanges iod(intOfDets); iod(); ++iod) {
      (*a)[count++] = iod.min();
      (*a)[count++] = iod.max();
    }
    return s << a;
  }

  template <class View0, class View1>
  ExecStatus
  IntersectionN<View0,View1>::propagate(Space* home) {

    bool repeat = false;
    do {
      repeat = false;
      int xsize = x.size();

      for (int i = xsize; i--; ) {
        GECODE_ME_CHECK( y.cardMax(home,x[i].cardMax()) );
        GECODE_ME_CHECK( x[i].cardMin(home,y.cardMin()) );
        if (x[i].cardMax()==0) {
          GECODE_ME_CHECK( y.exclude(home,
                                     Limits::Set::int_min,
                                     Limits::Set::int_max) );
          intOfDets.dispose(home);
          return ES_SUBSUMED(this,home);
        }
      }
      {
        GECODE_AUTOARRAY(GlbRanges<View0>,xLBs,xsize);
        GECODE_AUTOARRAY(LubRanges<View0>,xUBs,xsize);
        for (int i = xsize; i--; ) {
          GlbRanges<View0> lb(x[i]);
          LubRanges<View0> ub(x[i]);
          xLBs[i]=lb;
          xUBs[i]=ub;
        }
        Iter::Ranges::NaryInter<GlbRanges<View0> > lbi(xLBs,xsize);
        BndSetRanges dets1(intOfDets);
        Iter::Ranges::Inter< Iter::Ranges::NaryInter<GlbRanges<View0> >,
          BndSetRanges >
          lbiAll(lbi,dets1);
        GECODE_ME_CHECK( y.includeI(home,lbiAll) );

        Iter::Ranges::NaryInter<LubRanges<View0> > ubi(xUBs,xsize);
        BndSetRanges dets2(intOfDets);
        Iter::Ranges::Inter< Iter::Ranges::NaryInter<LubRanges<View0> >,
          BndSetRanges >
          ubiAll(ubi,dets2);
        GECODE_ME_CHECK( y.intersectI(home,ubiAll) );
      }

      for (int i = xsize; i--; ) {
        GlbRanges<View1> ylb(y);
        GECODE_ME_CHECK( x[i].includeI(home,ylb) );
      }

      // xi.exclude (Intersection(xj.lb) - y.ub)
      {
        GECODE_AUTOARRAY(GLBndSet, rightSet, xsize);
        new (&rightSet[xsize-1]) GLBndSet(home);
        rightSet[xsize-1].update(home,intOfDets);
        for (int i=xsize-1;i--;) {
          GlbRanges<View0> xilb(x[i+1]);
          BndSetRanges prev(rightSet[i+1]);
          Iter::Ranges::Inter<GlbRanges<View0>,
            BndSetRanges> inter(xilb,prev);
          new (&rightSet[i]) GLBndSet(home);
          rightSet[i].includeI(home,inter);
        }

        LUBndSet leftAcc(home);

        for (int i=0;i<xsize;i++) {
          BndSetRanges left(leftAcc);
          BndSetRanges right(rightSet[i]);
          Iter::Ranges::Inter<BndSetRanges,
            BndSetRanges> inter(left, right);
          LubRanges<View1> yub(y);
          Iter::Ranges::Diff<Iter::Ranges::Inter<BndSetRanges,
            BndSetRanges>, LubRanges<View1> >
            forbidden(inter, yub);
          GECODE_ME_CHECK( x[i].excludeI(home,forbidden) );
          GlbRanges<View0> xlb(x[i]);
          leftAcc.intersectI(home,xlb);
        }
        for (int i=xsize; i--;)
          rightSet[i].dispose(home);
        leftAcc.dispose(home);
      }


      for(int i=0;i<x.size();i++){
        //Do not reverse! Eats away the end of the array!
        while (i<x.size() && x[i].assigned()) {
          GlbRanges<View0> det(x[i]);
          if (intOfDets.intersectI(home,det)) {repeat = true;}
          x.move_lst(i);
          if (intOfDets.size()==0) {
            GECODE_ME_CHECK( y.exclude(home,Limits::Set::int_min,
                                       Limits::Set::int_max) );
            intOfDets.dispose(home);
            return ES_SUBSUMED(this,home);
          }
        }
      }
      if (x.size()==0) {
        BndSetRanges all1(intOfDets);
        GECODE_ME_CHECK( y.intersectI(home,all1) );
        BndSetRanges all2(intOfDets);
        GECODE_ME_CHECK( y.includeI(home,all2) );
        intOfDets.dispose(home);
        return ES_SUBSUMED(this,home);
      }

    } while (repeat);

    return shared ? ES_NOFIX : ES_FIX;
  }

}}}

// STATISTICS: set-prop
